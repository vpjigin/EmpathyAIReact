{"ast":null,"code":"export class WebSocketService {\n  constructor(onTranscription, onError) {\n    this.ws = null;\n    this.conversationUuid = null;\n    this.onTranscription = null;\n    this.onError = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 1000;\n    this.onTranscription = onTranscription;\n    this.onError = onError;\n  }\n  connect(conversationUuid) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.conversationUuid = conversationUuid;\n        this.ws = new WebSocket('ws://localhost:8080/ws/audio-stream-native');\n        this.ws.onopen = () => {\n          var _this$ws;\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n\n          // Send session start message\n          const startMessage = {\n            type: \"start_streaming\",\n            conversation_uuid: conversationUuid\n          };\n          (_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.send(JSON.stringify(startMessage));\n          console.log('Sent start streaming message:', startMessage);\n          resolve();\n        };\n        this.ws.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            console.log('Received WebSocket message:', message);\n            if (this.onTranscription) {\n              this.onTranscription(message);\n            }\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n            if (this.onError) {\n              this.onError('Failed to parse server response');\n            }\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket error:', error);\n          if (this.onError) {\n            this.onError(`WebSocket connection error. Make sure the server is running at ws://localhost:8080/ws/audio-stream-native`);\n          }\n          reject(new Error(`WebSocket connection failed. Server may not be running.`));\n        };\n        this.ws.onclose = event => {\n          console.log('WebSocket closed unexpectedly:', {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean,\n            timestamp: new Date().toISOString()\n          });\n\n          // Only reconnect if it wasn't a clean close (code 1000) and we haven't exceeded attempts\n          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {\n            console.log(`WebSocket closed unexpectedly, attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n            setTimeout(() => {\n              this.reconnectAttempts++;\n              if (this.conversationUuid) {\n                console.log('Reconnecting to WebSocket...');\n                this.connect(this.conversationUuid).catch(console.error);\n              }\n            }, this.reconnectInterval);\n          } else if (event.code === 1000) {\n            console.log('WebSocket closed cleanly by user or server');\n          } else {\n            console.log('Max reconnection attempts reached, giving up');\n          }\n        };\n      } catch (error) {\n        console.error('Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n  sendAudioData(audioData) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(audioData);\n    } else {\n      console.warn('WebSocket not connected, cannot send audio data. State:', this.ws ? this.ws.readyState : 'null');\n\n      // Log the WebSocket state for debugging\n      if (this.ws) {\n        const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\n        console.warn('WebSocket state:', states[this.ws.readyState] || 'UNKNOWN');\n      }\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close(1000, 'User initiated disconnect');\n      this.ws = null;\n    }\n    this.conversationUuid = null;\n  }\n  isConnected() {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n}","map":{"version":3,"names":["WebSocketService","constructor","onTranscription","onError","ws","conversationUuid","reconnectAttempts","maxReconnectAttempts","reconnectInterval","connect","Promise","resolve","reject","WebSocket","onopen","_this$ws","console","log","startMessage","type","conversation_uuid","send","JSON","stringify","onmessage","event","message","parse","data","error","onerror","Error","onclose","code","reason","wasClean","timestamp","Date","toISOString","setTimeout","catch","sendAudioData","audioData","readyState","OPEN","warn","states","disconnect","close","isConnected"],"sources":["/Users/jiginvp/react/AICompetition/empathy-ai/src/services/webSocketService.ts"],"sourcesContent":["export interface WebSocketMessage {\n  type: string;\n  message?: string;\n  conversation_uuid?: string;\n  transcript?: string;\n  reply?: string;\n  needsHumanIntervention?: boolean;\n  error?: string;\n}\n\nexport class WebSocketService {\n  private ws: WebSocket | null = null;\n  private conversationUuid: string | null = null;\n  private onTranscription: ((message: WebSocketMessage) => void) | null = null;\n  private onError: ((error: string) => void) | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectInterval = 1000;\n\n  constructor(\n    onTranscription: (message: WebSocketMessage) => void,\n    onError: (error: string) => void\n  ) {\n    this.onTranscription = onTranscription;\n    this.onError = onError;\n  }\n\n  connect(conversationUuid: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.conversationUuid = conversationUuid;\n        this.ws = new WebSocket('ws://localhost:8080/ws/audio-stream-native');\n\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n          \n          // Send session start message\n          const startMessage = {\n            type: \"start_streaming\",\n            conversation_uuid: conversationUuid\n          };\n          \n          this.ws?.send(JSON.stringify(startMessage));\n          console.log('Sent start streaming message:', startMessage);\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            console.log('Received WebSocket message:', message);\n            \n            if (this.onTranscription) {\n              this.onTranscription(message);\n            }\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n            if (this.onError) {\n              this.onError('Failed to parse server response');\n            }\n          }\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          if (this.onError) {\n            this.onError(`WebSocket connection error. Make sure the server is running at ws://localhost:8080/ws/audio-stream-native`);\n          }\n          reject(new Error(`WebSocket connection failed. Server may not be running.`));\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('WebSocket closed unexpectedly:', {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean,\n            timestamp: new Date().toISOString()\n          });\n          \n          // Only reconnect if it wasn't a clean close (code 1000) and we haven't exceeded attempts\n          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {\n            console.log(`WebSocket closed unexpectedly, attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n            setTimeout(() => {\n              this.reconnectAttempts++;\n              if (this.conversationUuid) {\n                console.log('Reconnecting to WebSocket...');\n                this.connect(this.conversationUuid).catch(console.error);\n              }\n            }, this.reconnectInterval);\n          } else if (event.code === 1000) {\n            console.log('WebSocket closed cleanly by user or server');\n          } else {\n            console.log('Max reconnection attempts reached, giving up');\n          }\n        };\n\n      } catch (error) {\n        console.error('Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n\n  sendAudioData(audioData: ArrayBuffer): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(audioData);\n    } else {\n      console.warn('WebSocket not connected, cannot send audio data. State:', \n        this.ws ? this.ws.readyState : 'null');\n      \n      // Log the WebSocket state for debugging\n      if (this.ws) {\n        const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\n        console.warn('WebSocket state:', states[this.ws.readyState] || 'UNKNOWN');\n      }\n    }\n  }\n\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close(1000, 'User initiated disconnect');\n      this.ws = null;\n    }\n    this.conversationUuid = null;\n  }\n\n  isConnected(): boolean {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}