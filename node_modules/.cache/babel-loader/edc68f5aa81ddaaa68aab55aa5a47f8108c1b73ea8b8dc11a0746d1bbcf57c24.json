{"ast":null,"code":"export class WebSocketService {\n  constructor(onTranscription, onError) {\n    this.ws = null;\n    this.conversationUuid = null;\n    this.onTranscription = null;\n    this.onError = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 1000;\n    this.onTranscription = onTranscription;\n    this.onError = onError;\n  }\n  connect(conversationUuid) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.conversationUuid = conversationUuid;\n        this.ws = new WebSocket('ws://localhost:8080/ws/audio-stream');\n        this.ws.onopen = () => {\n          var _this$ws;\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n\n          // Send session start message\n          const startMessage = {\n            type: \"start_streaming\",\n            conversation_uuid: conversationUuid\n          };\n          (_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.send(JSON.stringify(startMessage));\n          console.log('Sent start streaming message:', startMessage);\n          resolve();\n        };\n        this.ws.onmessage = event => {\n          try {\n            const message = JSON.parse(event.data);\n            console.log('Received WebSocket message:', message);\n            if (this.onTranscription) {\n              this.onTranscription(message);\n            }\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n            if (this.onError) {\n              this.onError('Failed to parse server response');\n            }\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('WebSocket error:', error);\n          if (this.onError) {\n            this.onError('WebSocket connection error');\n          }\n          reject(error);\n        };\n        this.ws.onclose = event => {\n          console.log('WebSocket closed:', event.code, event.reason);\n          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {\n            setTimeout(() => {\n              console.log(`Attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n              this.reconnectAttempts++;\n              if (this.conversationUuid) {\n                this.connect(this.conversationUuid).catch(console.error);\n              }\n            }, this.reconnectInterval);\n          }\n        };\n      } catch (error) {\n        console.error('Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n  sendAudioData(audioData) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(audioData);\n    } else {\n      console.warn('WebSocket not connected, cannot send audio data');\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close(1000, 'User initiated disconnect');\n      this.ws = null;\n    }\n    this.conversationUuid = null;\n  }\n  isConnected() {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n}","map":{"version":3,"names":["WebSocketService","constructor","onTranscription","onError","ws","conversationUuid","reconnectAttempts","maxReconnectAttempts","reconnectInterval","connect","Promise","resolve","reject","WebSocket","onopen","_this$ws","console","log","startMessage","type","conversation_uuid","send","JSON","stringify","onmessage","event","message","parse","data","error","onerror","onclose","code","reason","setTimeout","catch","sendAudioData","audioData","readyState","OPEN","warn","disconnect","close","isConnected"],"sources":["/Users/jiginvp/react/AICompetition/empathy-ai/src/services/webSocketService.ts"],"sourcesContent":["export interface WebSocketMessage {\n  type: string;\n  conversation_uuid?: string;\n  transcription?: string;\n  transcriptionReply?: string;\n  needHumanIntervention?: boolean;\n  error?: string;\n}\n\nexport class WebSocketService {\n  private ws: WebSocket | null = null;\n  private conversationUuid: string | null = null;\n  private onTranscription: ((message: WebSocketMessage) => void) | null = null;\n  private onError: ((error: string) => void) | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectInterval = 1000;\n\n  constructor(\n    onTranscription: (message: WebSocketMessage) => void,\n    onError: (error: string) => void\n  ) {\n    this.onTranscription = onTranscription;\n    this.onError = onError;\n  }\n\n  connect(conversationUuid: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.conversationUuid = conversationUuid;\n        this.ws = new WebSocket('ws://localhost:8080/ws/audio-stream');\n\n        this.ws.onopen = () => {\n          console.log('WebSocket connected');\n          this.reconnectAttempts = 0;\n          \n          // Send session start message\n          const startMessage = {\n            type: \"start_streaming\",\n            conversation_uuid: conversationUuid\n          };\n          \n          this.ws?.send(JSON.stringify(startMessage));\n          console.log('Sent start streaming message:', startMessage);\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            console.log('Received WebSocket message:', message);\n            \n            if (this.onTranscription) {\n              this.onTranscription(message);\n            }\n          } catch (error) {\n            console.error('Error parsing WebSocket message:', error);\n            if (this.onError) {\n              this.onError('Failed to parse server response');\n            }\n          }\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          if (this.onError) {\n            this.onError('WebSocket connection error');\n          }\n          reject(error);\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('WebSocket closed:', event.code, event.reason);\n          \n          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {\n            setTimeout(() => {\n              console.log(`Attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\n              this.reconnectAttempts++;\n              if (this.conversationUuid) {\n                this.connect(this.conversationUuid).catch(console.error);\n              }\n            }, this.reconnectInterval);\n          }\n        };\n\n      } catch (error) {\n        console.error('Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n\n  sendAudioData(audioData: ArrayBuffer): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(audioData);\n    } else {\n      console.warn('WebSocket not connected, cannot send audio data');\n    }\n  }\n\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close(1000, 'User initiated disconnect');\n      this.ws = null;\n    }\n    this.conversationUuid = null;\n  }\n\n  isConnected(): boolean {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}