{"ast":null,"code":"const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080';\nexport class AudioService {\n  static async sendAudioToServer(audioBlob) {\n    try {\n      console.log('Sending audio blob:', {\n        size: audioBlob.size,\n        type: audioBlob.type\n      });\n      if (audioBlob.size === 0) {\n        throw new Error('Audio blob is empty');\n      }\n      const formData = new FormData();\n      formData.append('file', audioBlob, 'recording.webm');\n      const response = await fetch(`${API_BASE_URL}/api/audio`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Server responded with status: ${response.status}`);\n      }\n      const result = await response.json();\n      if (result.status === 'success') {\n        return {\n          success: true,\n          status: result.status,\n          message: result.message,\n          filename: result.filename,\n          transcription: result.transcription,\n          needHumanIntervention: result.needHumanIntervention\n        };\n      } else {\n        return {\n          success: false,\n          error: result.error || 'Failed to transcribe audio'\n        };\n      }\n    } catch (error) {\n      console.error('Error communicating with server:', error);\n      return {\n        success: false,\n        error: error.message || 'Failed to connect to server. Please check your connection.'\n      };\n    }\n  }\n  static async downloadAudio(audioUrl) {\n    try {\n      const response = await fetch(audioUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to download audio: ${response.status}`);\n      }\n      return await response.blob();\n    } catch (error) {\n      console.error('Error downloading audio:', error);\n      return null;\n    }\n  }\n  static createAudioUrl(audioBlob) {\n    return URL.createObjectURL(audioBlob);\n  }\n  static releaseAudioUrl(audioUrl) {\n    URL.revokeObjectURL(audioUrl);\n  }\n}","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","AudioService","sendAudioToServer","audioBlob","console","log","size","type","Error","formData","FormData","append","response","fetch","method","body","headers","ok","status","result","json","success","message","filename","transcription","needHumanIntervention","error","downloadAudio","audioUrl","blob","createAudioUrl","URL","createObjectURL","releaseAudioUrl","revokeObjectURL"],"sources":["/Users/jiginvp/react/AICompetition/empathy-ai/src/services/audioService.ts"],"sourcesContent":["const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080';\n\nexport interface AudioResponse {\n  success: boolean;\n  audioUrl?: string;\n  message?: string;\n  error?: string;\n  status?: string;\n  filename?: string;\n  transcription?: string;\n  needHumanIntervention?: boolean;\n}\n\nexport class AudioService {\n  static async sendAudioToServer(audioBlob: Blob): Promise<AudioResponse> {\n    try {\n      console.log('Sending audio blob:', {\n        size: audioBlob.size,\n        type: audioBlob.type\n      });\n      \n      if (audioBlob.size === 0) {\n        throw new Error('Audio blob is empty');\n      }\n      \n      const formData = new FormData();\n      formData.append('file', audioBlob, 'recording.webm');\n      \n      const response = await fetch(`${API_BASE_URL}/api/audio`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server responded with status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      \n      if (result.status === 'success') {\n        return {\n          success: true,\n          status: result.status,\n          message: result.message,\n          filename: result.filename,\n          transcription: result.transcription,\n          needHumanIntervention: result.needHumanIntervention,\n        };\n      } else {\n        return {\n          success: false,\n          error: result.error || 'Failed to transcribe audio',\n        };\n      }\n    } catch (error: any) {\n      console.error('Error communicating with server:', error);\n      \n      return {\n        success: false,\n        error: error.message || 'Failed to connect to server. Please check your connection.',\n      };\n    }\n  }\n\n  static async downloadAudio(audioUrl: string): Promise<Blob | null> {\n    try {\n      const response = await fetch(audioUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to download audio: ${response.status}`);\n      }\n      return await response.blob();\n    } catch (error) {\n      console.error('Error downloading audio:', error);\n      return null;\n    }\n  }\n\n  static createAudioUrl(audioBlob: Blob): string {\n    return URL.createObjectURL(audioBlob);\n  }\n\n  static releaseAudioUrl(audioUrl: string): void {\n    URL.revokeObjectURL(audioUrl);\n  }\n}"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,uBAAuB;AAa7E,OAAO,MAAMC,YAAY,CAAC;EACxB,aAAaC,iBAAiBA,CAACC,SAAe,EAA0B;IACtE,IAAI;MACFC,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE;QACjCC,IAAI,EAAEH,SAAS,CAACG,IAAI;QACpBC,IAAI,EAAEJ,SAAS,CAACI;MAClB,CAAC,CAAC;MAEF,IAAIJ,SAAS,CAACG,IAAI,KAAK,CAAC,EAAE;QACxB,MAAM,IAAIE,KAAK,CAAC,qBAAqB,CAAC;MACxC;MAEA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;MAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAER,SAAS,EAAE,gBAAgB,CAAC;MAEpD,MAAMS,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGhB,YAAY,YAAY,EAAE;QACxDiB,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEN,QAAQ;QACdO,OAAO,EAAE;UACP,QAAQ,EAAE;QACZ;MACF,CAAC,CAAC;MAEF,IAAI,CAACJ,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAM,IAAIT,KAAK,CAAC,iCAAiCI,QAAQ,CAACM,MAAM,EAAE,CAAC;MACrE;MAEA,MAAMC,MAAM,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;MAEpC,IAAID,MAAM,CAACD,MAAM,KAAK,SAAS,EAAE;QAC/B,OAAO;UACLG,OAAO,EAAE,IAAI;UACbH,MAAM,EAAEC,MAAM,CAACD,MAAM;UACrBI,OAAO,EAAEH,MAAM,CAACG,OAAO;UACvBC,QAAQ,EAAEJ,MAAM,CAACI,QAAQ;UACzBC,aAAa,EAAEL,MAAM,CAACK,aAAa;UACnCC,qBAAqB,EAAEN,MAAM,CAACM;QAChC,CAAC;MACH,CAAC,MAAM;QACL,OAAO;UACLJ,OAAO,EAAE,KAAK;UACdK,KAAK,EAAEP,MAAM,CAACO,KAAK,IAAI;QACzB,CAAC;MACH;IACF,CAAC,CAAC,OAAOA,KAAU,EAAE;MACnBtB,OAAO,CAACsB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MAExD,OAAO;QACLL,OAAO,EAAE,KAAK;QACdK,KAAK,EAAEA,KAAK,CAACJ,OAAO,IAAI;MAC1B,CAAC;IACH;EACF;EAEA,aAAaK,aAAaA,CAACC,QAAgB,EAAwB;IACjE,IAAI;MACF,MAAMhB,QAAQ,GAAG,MAAMC,KAAK,CAACe,QAAQ,CAAC;MACtC,IAAI,CAAChB,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAM,IAAIT,KAAK,CAAC,6BAA6BI,QAAQ,CAACM,MAAM,EAAE,CAAC;MACjE;MACA,OAAO,MAAMN,QAAQ,CAACiB,IAAI,CAAC,CAAC;IAC9B,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdtB,OAAO,CAACsB,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO,IAAI;IACb;EACF;EAEA,OAAOI,cAAcA,CAAC3B,SAAe,EAAU;IAC7C,OAAO4B,GAAG,CAACC,eAAe,CAAC7B,SAAS,CAAC;EACvC;EAEA,OAAO8B,eAAeA,CAACL,QAAgB,EAAQ;IAC7CG,GAAG,CAACG,eAAe,CAACN,QAAQ,CAAC;EAC/B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}