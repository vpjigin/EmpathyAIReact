{"ast":null,"code":"const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001';\nexport class AudioService {\n  static async sendAudioToServer(audioBlob) {\n    try {\n      const formData = new FormData();\n      formData.append('audio', audioBlob, 'recording.webm');\n      const response = await fetch(`${API_BASE_URL}/api/process-audio`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Server responded with status: ${response.status}`);\n      }\n      const result = await response.json();\n      if (result.audioUrl) {\n        return {\n          success: true,\n          audioUrl: result.audioUrl,\n          message: result.message\n        };\n      } else {\n        return {\n          success: false,\n          error: result.error || 'No audio response received'\n        };\n      }\n    } catch (error) {\n      console.error('Error communicating with server:', error);\n      return {\n        success: false,\n        error: error.message || 'Failed to connect to server. Please check your connection.'\n      };\n    }\n  }\n  static async downloadAudio(audioUrl) {\n    try {\n      const response = await fetch(audioUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to download audio: ${response.status}`);\n      }\n      return await response.blob();\n    } catch (error) {\n      console.error('Error downloading audio:', error);\n      return null;\n    }\n  }\n  static createAudioUrl(audioBlob) {\n    return URL.createObjectURL(audioBlob);\n  }\n  static releaseAudioUrl(audioUrl) {\n    URL.revokeObjectURL(audioUrl);\n  }\n}","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","AudioService","sendAudioToServer","audioBlob","formData","FormData","append","response","fetch","method","body","headers","ok","Error","status","result","json","audioUrl","success","message","error","console","downloadAudio","blob","createAudioUrl","URL","createObjectURL","releaseAudioUrl","revokeObjectURL"],"sources":["/Users/jiginvp/react/AICompetition/empathy-ai/src/services/audioService.ts"],"sourcesContent":["const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001';\n\nexport interface AudioResponse {\n  success: boolean;\n  audioUrl?: string;\n  message?: string;\n  error?: string;\n}\n\nexport class AudioService {\n  static async sendAudioToServer(audioBlob: Blob): Promise<AudioResponse> {\n    try {\n      const formData = new FormData();\n      formData.append('audio', audioBlob, 'recording.webm');\n      \n      const response = await fetch(`${API_BASE_URL}/api/process-audio`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server responded with status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      \n      if (result.audioUrl) {\n        return {\n          success: true,\n          audioUrl: result.audioUrl,\n          message: result.message,\n        };\n      } else {\n        return {\n          success: false,\n          error: result.error || 'No audio response received',\n        };\n      }\n    } catch (error: any) {\n      console.error('Error communicating with server:', error);\n      \n      return {\n        success: false,\n        error: error.message || 'Failed to connect to server. Please check your connection.',\n      };\n    }\n  }\n\n  static async downloadAudio(audioUrl: string): Promise<Blob | null> {\n    try {\n      const response = await fetch(audioUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to download audio: ${response.status}`);\n      }\n      return await response.blob();\n    } catch (error) {\n      console.error('Error downloading audio:', error);\n      return null;\n    }\n  }\n\n  static createAudioUrl(audioBlob: Blob): string {\n    return URL.createObjectURL(audioBlob);\n  }\n\n  static releaseAudioUrl(audioUrl: string): void {\n    URL.revokeObjectURL(audioUrl);\n  }\n}"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,uBAAuB;AAS7E,OAAO,MAAMC,YAAY,CAAC;EACxB,aAAaC,iBAAiBA,CAACC,SAAe,EAA0B;IACtE,IAAI;MACF,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;MAC/BD,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEH,SAAS,EAAE,gBAAgB,CAAC;MAErD,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGX,YAAY,oBAAoB,EAAE;QAChEY,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEN,QAAQ;QACdO,OAAO,EAAE;UACP,QAAQ,EAAE;QACZ;MACF,CAAC,CAAC;MAEF,IAAI,CAACJ,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,iCAAiCN,QAAQ,CAACO,MAAM,EAAE,CAAC;MACrE;MAEA,MAAMC,MAAM,GAAG,MAAMR,QAAQ,CAACS,IAAI,CAAC,CAAC;MAEpC,IAAID,MAAM,CAACE,QAAQ,EAAE;QACnB,OAAO;UACLC,OAAO,EAAE,IAAI;UACbD,QAAQ,EAAEF,MAAM,CAACE,QAAQ;UACzBE,OAAO,EAAEJ,MAAM,CAACI;QAClB,CAAC;MACH,CAAC,MAAM;QACL,OAAO;UACLD,OAAO,EAAE,KAAK;UACdE,KAAK,EAAEL,MAAM,CAACK,KAAK,IAAI;QACzB,CAAC;MACH;IACF,CAAC,CAAC,OAAOA,KAAU,EAAE;MACnBC,OAAO,CAACD,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MAExD,OAAO;QACLF,OAAO,EAAE,KAAK;QACdE,KAAK,EAAEA,KAAK,CAACD,OAAO,IAAI;MAC1B,CAAC;IACH;EACF;EAEA,aAAaG,aAAaA,CAACL,QAAgB,EAAwB;IACjE,IAAI;MACF,MAAMV,QAAQ,GAAG,MAAMC,KAAK,CAACS,QAAQ,CAAC;MACtC,IAAI,CAACV,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,6BAA6BN,QAAQ,CAACO,MAAM,EAAE,CAAC;MACjE;MACA,OAAO,MAAMP,QAAQ,CAACgB,IAAI,CAAC,CAAC;IAC9B,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO,IAAI;IACb;EACF;EAEA,OAAOI,cAAcA,CAACrB,SAAe,EAAU;IAC7C,OAAOsB,GAAG,CAACC,eAAe,CAACvB,SAAS,CAAC;EACvC;EAEA,OAAOwB,eAAeA,CAACV,QAAgB,EAAQ;IAC7CQ,GAAG,CAACG,eAAe,CAACX,QAAQ,CAAC;EAC/B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}